// auto generated by go tool dist

package runtime
import "unsafe"
var _ unsafe.Pointer

type lock struct {
	key	uint64
}

type note struct {
	key	uint64
}

type _string struct {
	str	*uint8
	len	int64
}

type funcval struct {
	fn	func()
}

type iface struct {
	tab	*itab
	data	unsafe.Pointer
}

type eface struct {
	_type	*_type
	data	unsafe.Pointer
}

type _complex64 struct {
	real	float32
	imag	float32
}

type _complex128 struct {
	real	float64
	imag	float64
}

type slice struct {
	array	*uint8
	len	uint64
	cap	uint64
}

type gobuf struct {
	sp	uint64
	pc	*uint8
	g	*g
}

type gcstats struct {
	nhandoff	uint64
	nhandoffcnt	uint64
	nprocyield	uint64
	nosyield	uint64
	nsleep	uint64
}

type g struct {
	stackguard	uint64
	stackbase	uint64
	_defer	*_defer
	_panic	*_panic
	sched	gobuf
	gcstack	uint64
	gcsp	uint64
	gcpc	*uint8
	gcguard	uint64
	stack0	uint64
	fnstart	*funcval
	alllink	*g
	param	unsafe.Pointer
	status	int16
	goid	int64
	selgen	uint32
	waitreason	*int8
	schedlink	*g
	ispanic	uint8
	issystem	uint8
	isbackground	uint8
	blockingsyscall	uint8
	raceignore	int8
	m	*m
	lockedm	*m
	sig	int32
	writenbuf	int32
	writebuf	*uint8
	dchunk	*deferchunk
	dchunknext	*deferchunk
	sigcode0	uint64
	sigcode1	uint64
	sigpc	uint64
	gopc	uint64
	racectx	uint64
	end	[0]uint64
}

type m struct {
	g0	*g
	morepc	func()
	moreargp	unsafe.Pointer
	morebuf	gobuf
	moreframesize	uint32
	moreargsize	uint32
	cret	uint64
	procid	uint64
	gsignal	*g
	tls	[4]uint64
	mstartfn	func()
	curg	*g
	p	*p
	nextp	*p
	id	int32
	mallocing	int32
	throwing	int32
	gcing	int32
	locks	int32
	nomemprof	int32
	dying	int32
	profilehz	int32
	helpgc	int32
	blockingsyscall	uint8
	spinning	uint8
	fastrand	uint32
	ncgocall	uint64
	ncgo	int32
	cgomal	*cgomal
	park	note
	alllink	*m
	schedlink	*m
	machport	uint32
	mcache	*mcache
	stackinuse	int32
	stackcachepos	uint32
	stackcachecnt	uint32
	stackcache	[32]unsafe.Pointer
	lockedg	*g
	createstack	[32]uint64
	freglo	[16]uint32
	freghi	[16]uint32
	fflag	uint32
	locked	uint32
	nextwaitm	*m
	waitsema	uint64
	waitsemacount	uint32
	waitsemalock	uint32
	gcstats	gcstats
	racecall	uint8
	needextram	uint8
	racepc	unsafe.Pointer
	waitunlockf	func(*lock)
	waitlock	unsafe.Pointer
	moreframesize_minalloc	uint32
	settype_buf	[1024]uint64
	settype_bufsize	uint64
	seh	*seh
	end	[0]uint64
}

type p struct {
	lock
	status	uint32
	link	*p
	tick	uint32
	m	*m
	mcache	*mcache
	runq	**g
	runqhead	int32
	runqtail	int32
	runqsize	int32
	gfree	*g
	gfreecnt	int32
	pad	[64]uint8
}

type stktop struct {
	stackguard	*uint8
	stackbase	*uint8
	gobuf	gobuf
	argsize	uint32
	argp	*uint8
	free	uint64
	_panic	uint8
}

type sigtab struct {
	flags	int32
	name	*int8
}

type _func struct {
	name	string
	_type	string
	src	string
	pcln	[]byte
	entry	uint64
	pc0	uint64
	ln0	int32
	frame	int32
	args	int32
	locals	int32
}

type itab struct {
	inter	*interfacetype
	_type	*_type
	link	*itab
	bad	int32
	unused	int32
	fun	[0]func()
}

type wincall struct {
	fn	func(unsafe.Pointer)
	n	uint64
	args	unsafe.Pointer
	r1	uint64
	r2	uint64
	err	uint64
}

type seh struct {
	prev	unsafe.Pointer
	handler	unsafe.Pointer
}

type timers struct {
	lock
	timerproc	*g
	sleeping	uint8
	rescheduling	uint8
	waitnote	note
	t	**timer
	len	int32
	cap	int32
}

type timer struct {
	i	int32
	when	int64
	period	int64
	fv	*funcval
	arg	eface
}

type lfnode struct {
	next	*lfnode
	pushcnt	uint64
}

type parfor struct {
	body	func(*parfor, uint32)
	done	uint32
	nthr	uint32
	nthrmax	uint32
	thrseq	uint32
	cnt	uint32
	ctx	unsafe.Pointer
	wait	uint8
	thr	*parforthread
	pad	uint32
	nsteal	uint64
	nstealcnt	uint64
	nprocyield	uint64
	nosyield	uint64
	nsleep	uint64
}

type cgomal struct {
	next	*cgomal
	alloc	unsafe.Pointer
}

type alg struct {
	hash	func(*uint64, uint64, unsafe.Pointer)
	equal	func(*uint8, uint64, unsafe.Pointer, unsafe.Pointer)
	print	func(uint64, unsafe.Pointer)
	copy	func(uint64, unsafe.Pointer, unsafe.Pointer)
}

var algarray	[22]alg
var startup_random_data	*uint8
var startup_random_data_len	uint32
type _defer struct {
	siz	int32
	special	uint8
	free	uint8
	argp	*uint8
	pc	*uint8
	fn	*funcval
	link	*_defer
	args	[1]unsafe.Pointer
}

type deferchunk struct {
	prev	*deferchunk
	off	uint64
}

type _panic struct {
	arg	eface
	stackbase	*uint8
	link	*_panic
	recovered	uint8
}

var emptystring	string
var zerobase	uint64
var allg	*g
var lastg	*g
var allm	*m
var allp	**p
var gomaxprocs	int32
var singleproc	uint8
var panicking	uint32
var gcwaiting	uint32
var goos	*int8
var ncpu	int32
var iscgo	uint8
var sysargs	func(int32, **uint8)
var maxstring	uint32
var hchansize	uint32
var cpuid_ecx	uint32
var cpuid_edx	uint32
var blockprofilerate	int64
var worldsema	uint32
var nan	float64
var posinf	float64
var neginf	float64
type mlink struct {
	next	*mlink
}

type fixalloc struct {
	size	uint64
	alloc	func(uint64) unsafe.Pointer
	first	func(unsafe.Pointer, *uint8)
	arg	unsafe.Pointer
	list	*mlink
	chunk	*uint8
	nchunk	uint32
	inuse	uint64
	sys	uint64
}

type _1_ struct {
	size	uint32
	nmalloc	uint64
	nfree	uint64
}

type mstats struct {
	alloc	uint64
	total_alloc	uint64
	sys	uint64
	nlookup	uint64
	nmalloc	uint64
	nfree	uint64
	heap_alloc	uint64
	heap_sys	uint64
	heap_idle	uint64
	heap_inuse	uint64
	heap_released	uint64
	heap_objects	uint64
	stacks_inuse	uint64
	stacks_sys	uint64
	mspan_inuse	uint64
	mspan_sys	uint64
	mcache_inuse	uint64
	mcache_sys	uint64
	buckhash_sys	uint64
	next_gc	uint64
	last_gc	uint64
	pause_total_ns	uint64
	pause_ns	[256]uint64
	numgc	uint32
	enablegc	uint8
	debuggc	uint8
	by_size	[61]_1_
}

var memstats	mstats
var class_to_size	[61]int32
var class_to_allocnpages	[61]int32
var class_to_transfercount	[61]int32
type mcachelist struct {
	list	*mlink
	nlist	uint32
	nlistmin	uint32
}

type _2_ struct {
	nmalloc	uint64
	nfree	uint64
}

type mcache struct {
	list	[61]mcachelist
	size	uint64
	local_cachealloc	int64
	local_objects	int64
	local_alloc	int64
	local_total_alloc	uint64
	local_nmalloc	uint64
	local_nfree	uint64
	local_nlookup	uint64
	next_sample	int32
	local_by_size	[61]_2_
}

type mtypes struct {
	compression	uint8
	sysalloc	uint8
	data	uint64
}

type mspan struct {
	next	*mspan
	prev	*mspan
	start	uint64
	npages	uint64
	freelist	*mlink
	ref	uint32
	sizeclass	int32
	elemsize	uint64
	state	uint32
	unusedsince	int64
	npreleased	uint64
	limit	*uint8
	types	mtypes
}

type mcentral struct {
	lock
	sizeclass	int32
	nonempty	mspan
	empty	mspan
	nfree	int32
}

type _3_ struct {
	mcentral
	pad	[64]uint8
}

type mheap struct {
	lock
	free	[256]mspan
	large	mspan
	allspans	**mspan
	nspan	uint32
	nspancap	uint32
	_map	[33554432]*mspan
	bitmap	*uint8
	bitmap_mapped	uint64
	arena_start	*uint8
	arena_used	*uint8
	arena_end	*uint8
	central	[61]_3_
	spanalloc	fixalloc
	cachealloc	fixalloc
}

var checking	int32
type _type struct {
	size	uint64
	hash	uint32
	_unused	uint8
	align	uint8
	fieldalign	uint8
	kind	uint8
	alg	*alg
	gc	unsafe.Pointer
	_string	*string
	x	*uncommontype
	ptrto	*_type
}

type method struct {
	name	*string
	pkgpath	*string
	mtyp	*_type
	typ	*_type
	ifn	func()
	tfn	func()
}

type uncommontype struct {
	name	*string
	pkgpath	*string
	mhdr	[]byte
	m	[0]method
}

type imethod struct {
	name	*string
	pkgpath	*string
	_type	*_type
}

type interfacetype struct {
	_type
	mhdr	[]byte
	m	[0]imethod
}

type maptype struct {
	_type
	key	*_type
	elem	*_type
}

type chantype struct {
	_type
	elem	*_type
	dir	uint64
}

type slicetype struct {
	_type
	elem	*_type
}

type functype struct {
	_type
	dotdotdot	uint8
	in	[]byte
	out	[]byte
}

type ptrtype struct {
	_type
	elem	*_type
}

type sched struct {
	lock
	goidgen	uint64
	midle	*m
	nmidle	int32
	mlocked	int32
	mcount	int32
	pidle	*p
	npidle	uint32
	nmspinning	uint32
	runqhead	*g
	runqtail	*g
	runqsize	int32
	gflock	lock
	gfree	*g
	stopwait	int32
	stopnote	note
	sysmonwait	uint32
	sysmonnote	note
	lastpoll	uint64
	profilehz	int32
}

var m0	m
var g0	g
var extram	*m
var newprocs	int32
var scavenger	funcval
var _cgo_thread_start	func(unsafe.Pointer)
type cgothreadstart struct {
	m	*m
	g	*g
	fn	func()
}

type _4_ struct {
	lock
	fn	func(*uint64, int32)
	hz	int32
	pcbuf	[100]uint64
}

var prof	_4_



















































var hash	[1009]*itab
var ifacelock	lock
var typelink	[0]*_type
var etypelink	[0]*_type









































type hash_gciter struct {
	h	*hmap
	phase	int32
	bucket	uint64
	b	*bucket
	i	uint64
}

type hash_gciter_data struct {
	st	*uint8
	key_data	*uint8
	val_data	*uint8
	indirectkey	uint8
	indirectval	uint8
}











type bucket struct {
	tophash	[8]uint8
	overflow	*bucket
	data	[1]uint8
}

type hmap struct {
	count	uint64
	flags	uint32
	b	uint8
	keysize	uint8
	valuesize	uint8
	bucketsize	uint16
	hash0	uint64
	buckets	*uint8
	oldbuckets	*uint8
	nevacuate	uint64
}

var empty_value	[128]uint8
type hash_iter struct {
	key	*uint8
	value	*uint8
	t	*maptype
	h	*hmap
	endbucket	uint64
	wrapped	uint8
	b	uint8
	buckets	*uint8
	bucket	uint64
	bptr	*bucket
	i	uint64
	check_bucket	int64
}




















































var debug	int32
type sudog struct {
	g	*g
	selgen	uint32
	link	*sudog
	releasetime	int64
	elem	*uint8
}

type waitq struct {
	first	*sudog
	last	*sudog
}

type hchan struct {
	qcount	uint64
	dataqsiz	uint64
	elemsize	uint16
	closed	uint8
	elemalign	uint8
	elemalg	*alg
	sendx	uint64
	recvx	uint64
	recvq	waitq
	sendq	waitq
	lock
}

type scase struct {
	sg	sudog
	_chan	*hchan
	pc	*uint8
	kind	uint16
	so	uint16
	receivedp	*uint8
}

type _select struct {
	tcase	uint16
	ncase	uint16
	pollorder	*uint16
	lockorder	**hchan
	scase	[1]scase
}

type runtimeselect struct {
	dir	uint64
	typ	*chantype
	ch	*hchan
	val	uint64
}






























type parforthread struct {
	pos	uint64
	nsteal	uint64
	nstealcnt	uint64
	nprocyield	uint64
	nosyield	uint64
	nsleep	uint64
	pad	[64]uint8
}

