#!/usr/bin/ruby -w
# Programmer: Chris Bunch


# Imports within Ruby's standard libraries
require 'openssl'
require 'soap/rpc/driver'
require 'timeout'


# Imports for AppController libraries
$:.unshift File.join(File.dirname(__FILE__))
require 'helperfunctions'


class InfrastructureManagerClient


  # The port that the InfrastructureManager runs on, by default.
  SERVER_PORT = 17444


  # A constant that indicates that there should be no timeout on SOAP calls.
  NO_TIMEOUT = -1


  # A constant that callers can use to indicate that SOAP calls should be
  # retried if they fail (e.g., if the connection was refused).
  RETRY_ON_FAIL = true


  # A constant that callers can use to indicate that SOAP calls should not
  # be retried if they fail.
  ABORT_ON_FAIL = false


  # The SOAP client that we use to communicate with the InfrastructureManager.
  attr_accessor :conn


  # The secret string that is used to authenticate this client with
  # InfrastructureManagers. It is initially generated by 
  # appscale-run-instances and can be found on the machine that ran that tool,
  # or on any AppScale machine.
  attr_accessor :secret


  def initialize(secret)
    ip = HelperFunctions.local_ip()
    @secret = secret
    
    @conn = SOAP::RPC::Driver.new("https://#{ip}:#{SERVER_PORT}")
    @conn.add_method("get_queues_in_use", "secret")
    @conn.add_method("run_instances", "parameters", "secret")
    @conn.add_method("describe_instances", "parameters", "secret")
    @conn.add_method("terminate_instances", "parameters", "secret")
  end
  

  # A helper method that makes SOAP calls for us. This method is mainly here to
  # reduce code duplication: all SOAP calls expect a certain timeout and can
  # tolerate certain exceptions, so we consolidate this code into this method.
  # Here, the caller specifies the timeout for the SOAP call (or NO_TIMEOUT
  # if an infinite timeout is required) as well as whether the call should
  # be retried in the face of exceptions. Exceptions can occur if the machine
  # is not yet running or is too busy to handle the request, so these exceptions
  # are automatically retried regardless of the retry value. Typically
  # callers set this to false to catch 'Connection Refused' exceptions or
  # the like. Finally, the caller must provide a block of
  # code that indicates the SOAP call to make: this is really all that differs
  # between the calling methods. The result of the block is returned to the
  # caller. 
  def make_call(time, retry_on_except, callr, ok_to_fail=false)
    refused_count = 0
    max = 5

    begin
      Timeout::timeout(time) {
        yield if block_given?
      }
    rescue Errno::ECONNREFUSED, Errno::EHOSTUNREACH => except
      Kernel.puts("Saw an Exception of class #{except.class}")
      if refused_count > max
        return false if ok_to_fail
        raise AppScaleException.new("Connection was refused. Is the " +
          "AppController running?")
      else
        refused_count += 1
        Kernel.sleep(1)
        retry
      end
    rescue Timeout::Error
      Kernel.puts("Saw a Timeout Error")
      return false if ok_to_fail
      retry
    rescue OpenSSL::SSL::SSLError, NotImplementedError, Errno::EPIPE, Errno::ECONNRESET => except
      Kernel.puts("Saw an Exception of class #{except.class}")
      Kernel.sleep(1)
      retry
    rescue Exception => except
      newline = "\n"
      Kernel.puts("Saw an Exception of class #{except.class}")
      Kernel.puts("#{except.backtrace.join(newline)}")

      if retry_on_except
        Kernel.sleep(1)
        retry
      else
        raise AppScaleException.new("[#{callr}] We saw an unexpected error of" +
          " the type #{except.class} with the following message:\n#{except}.")
      end
    end
  end


  def run_instances(parameters)
    Kernel.puts("Calling run_instances with parameters " +
      "#{parameters.inspect}")

    make_call(NO_TIMEOUT, RETRY_ON_FAIL, "run_instances") { 
      @conn.run_instances(parameters, @secret)
    }
  end

  
  def describe_instances(parameters)
    Kernel.puts("Calling describe_instances with parameters " +
      "#{parameters.inspect}")

    make_call(NO_TIMEOUT, RETRY_ON_FAIL, "describe_instances") { 
      @conn.describe_instances(parameters, @secret)
    }
  end


  def terminate_instances(parameters)
    Kernel.puts("Calling terminate_instances with parameters " +
      "#{parameters.inspect}")

    make_call(NO_TIMEOUT, RETRY_ON_FAIL, "terminate_instances") { 
      @conn.terminate_instances(parameters, @secret)
    }
  end
 
  
  def spawn_vms(num_vms, creds, job, cloud)
    credentials = {
      'EC2_ACCESS_KEY' => creds['ec2_access_key'],
      'EC2_SECRET_KEY' => creds['ec2_secret_key'],
      'EC2_URL' => creds['ec2_url']
    }

    run_result = run_instances("credentials" => credentials,
      "group" => creds['group'], 
      "image_id" => creds['machine'],
      "infrastructure" => creds['infrastructure'],
      "instance_type" => creds['instance_type'],
      "keyname" => creds['keyname'],
      "num_vms" => "#{num_vms}",
      "cloud" => cloud,
      "spot" => "false")
    Kernel.puts("[IM] Run instances info says [#{run_result}]")
    reservation_id = run_result['reservation_id']

    vm_info = {}
    loop {
      describe_result = describe_instances("reservation_id" => reservation_id)
      Kernel.puts("[IM] Describe instances info says [#{describe_result}]")

      if describe_result["state"] == "running"
        vm_info = describe_result["vm_info"]
        break
      end

      Kernel.sleep(10)
    }

    # now, turn this info back into the format we normally use
    jobs = []
    if job.is_a?(String)
      # We only got one job, so just repeat it for each one of the nodes
      vm_info['public_ips'].length.times { |i| jobs << job }
    else
      jobs = job
    end
    
    # ip:job:instance-id
    instances_created = []
    vm_info['public_ips'].each_index { |index|
      instances_created << "#{vm_info['public_ips'][index]}:#{vm_info['private_ips'][index]}:#{jobs[index]}:#{vm_info['instance_ids'][index]}:#{cloud}"
    }

    return instances_created
  end


end

